--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						"math_model.cpp"
included: 
"modelbody.cpp" - файл, где находится реализация базового класса "Base", и класса "Mathmodel", который является наследником "Base". 
 - вклюает в себя описание виртуальных методов:
	virtual void init() - производит инициализацию TCP сервера и клиента, подготавливает первоначальные данные 
		математической модели апериодического звена (расчет выходного значения без сигнала управления).
	virtual void update() - производит вычисление выходного значения мат.модели, с новым заданным значением
		управляющего сигнала. Должен вызываться в отдельном потоке, обслуживающим принятые сигналы
		от системы управления (регулятора).
 - локальных методов:
	void get_objectDefaultState() - задает первоначальные данные для мат.модели.
	float get_objectOutput(float input) - производит расчет выходного сигнала мат.модели по указанному в аргументе входному сигналу.
	void showParameters() - выводит в терминал параметры мат.модели (которые пользователь указывает при запуске приложения).
	void send_modelOutput(int s_Id) - отправляет сигнал в котором содержится значение выхода мат.модели (значение "output", которое хранится
		в структуре data_t modelData. В качестве аргумента принимает значение ID, которым "пометится" отправляемый сигнал.
	void send_modelOutputPrev(int s_Id) - отправляет сигнал в котором содержится значение выхода мат.модели в предыдущей итерации 
		(значение "output_prev", которое хранится в структуре data_t modelData. В качестве аргумента принимает значение ID, 
		которым "пометится" отправляемый сигнал.
	float pop_controlsignal_value() - функция, которая берет принятый сигнал из очереди сигналов, получает с этого сигнала "value" и возвращает.
	void waiting_newsignal() - блокирует поток, пока не будут получены сигналы, доступные для обработки (пока число элементов очереди не станет больше 0).
	void stop_waiting_newsignal() - уничтожает семафор, блокирующий поток.
	-используемые структуры:
	data_t - параметры модели.
	recvsignal_data_t - структура для передачи аргументов в поток, принимающий сигналы от клиента.
"queue.cpp" - файл, который включает в себя реализацию потокобезопасной очереди, которая может хранить в себе указатели 
	на различный тип данных (любую структуру, представленную как void*).
"tcplib.cpp" - файл, включающий в себя реализацию классов "TCP_client" и "TCP_server", набор соответствующих методов для инициализации
	TCP-соединения, передачи и приема данных.
"signal.cpp" - файл, в котором находится описание структуры сигнала, содержащего имя сигнала, id и значения (value). 
	Также, в этом файле расположены все функции для работы с сигналами: создание сигнала, создание символьного сообщения из структуры,
	получение символьного сообщения из готовой структуры, а также парсинг имени сигнала, парсинг id сигнала, парсинг значения сигнала.
Описание работы:
	Производится инициализация объекта класса Mathmodel (которая включает в себя настройку всех необходимых подключений).
	Создаются два потока, один принимает сигналы и складывает в потокобезопасную очередь, после чего разблокирует второй поток
	посредством семафора, второй поток находится в ожидании сигнала от семафора, как только сигнал приходит, производится получение и
	обработка сигнала из очереди. Далее второй поток вызывает метод  update() для объекта класса Mathmodel 
	и отправляет результат в систему управления как сигнал обратной связи.
	И так, по циклу, пока приходят сигналы от системы управления, либо по завершению заданного интервала времени моделирования.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						"control_system.cpp"
included: 
"controlbody.cpp" - файл, где находится реализация базового класса "Base", и класса "Control", который является наследником "Base". 
- вклюает в себя описание виртуальных методов:
	virtual void init() - производит инициализацию TCP сервера и клиента, подготавливает первоначальные данные 
	системы управления, использующая ПИ-регулятор.
	virtual void update() - производит вычисление выходного значения регулятора, с новым заданным значением
		обратной связи. Должен вызываться в отдельном потоке, обслуживающим принятые сигналы
		от математической модели.
 - локальных методов:
	void get_controlDefaultState() - задает первоначальные данные для мат.модели.
	float get_controlOutput(float input) - производит расчет выходного сигнала ПИ-регулятора по указанному в аргументе входному сигналу.
	void showParameters() - выводит в терминал параметры системы управления (которые пользователь указывает при запуске приложения).
	void send_controlOutput(int s_Id) - отправляет сигнал в котором содержится значение выхода ПИ-регулятора (значение "output", которое хранится
		в структуре data_t controlData. В качестве аргумента принимает значение ID, которым "пометится" отправляемый сигнал.
	void send_loggerResults(int s_Id) - отправляет сигналы по данной итерации в логгер. Каждый отправляемый сигнал требует подтверждения в виде эхо от логгера, 
		следовательно, данная функция заблокирует поток в случае сбоев работы логгера.
	void pop_modelsignal_value() - функция, которая берет принятый сигнал из очереди сигналов, получает с этого сигнала "value" и возвращает.
	void waiting_newsignal() - блокирует поток, пока не будут получены сигналы, доступные для обработки (пока число элементов очереди не станет больше 0).
	void stop_waiting_newsignal() - уничтожает семафор, блокирующий поток.
	-используемые структуры:
	data_t - параметры системы управления.
	recvsignal_data_t - структура для передачи аргументов в поток, принимающий сигналы от клиента.
"queue.cpp" - файл, который включает в себя реализацию потокобезопасной очереди, которая может хранить в себе указатели 
	на различный тип данных (любую структуру, представленную как void*).
"tcplib.cpp" - файл, включающий в себя реализацию классов "TCP_client" и "TCP_server", набор соответствующих методов для инициализации
	TCP-соединения, передачи и приема данных.
"signal.cpp" - файл, в котором находится описание структуры сигнала, содержащего имя сигнала, id и значения (value). 
	Также, в этом файле расположены все функции для работы с сигналами: создание сигнала, создание символьного сообщения из структуры,
	получение символьного сообщения из готовой структуры, а также парсинг имени сигнала, парсинг id сигнала, парсинг значения сигнала.
Описание работы:
	Производится инициализация объекта класса Control (которая включает в себя настройку всех необходимых подключений).
	Создаются два потока, один принимает сигналы и складывает в потокобезопасную очередь, после чего разблокирует второй поток
	посредством семафора, второй поток находится в ожидании сигнала от семафора, как только сигнал приходит, производится получение и
	обработка сигнала из очереди. Далее второй поток вызывает метод  update() для объекта класса Control. 
	После произведенного расчета второй поток отправляет данные в приложение logger, дожидаясь подтверждения принятого сигнала. 
	После отправки сигналов с результатами расчетов по данной итерации, происходит отправка сигнала управления в приложение math_model. 
	И так, по циклу, пока приходят сигналы от мат.модели.

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						"logger.cpp"
included: 
"loggerbody.cpp" - файл, где находится реализация базового класса "Base", и класса "Logger", который является наследником "Base". 
- вклюает в себя описание виртуальных методов:
	virtual void init() - производит инициализацию TCP сервера, создает файл-лог, проверяет возможность записи в указанный файл. .
	virtual void update() - производит запись принятых сигналов по каждой итерации в лог-файл. Должен вызываться в отдельном потоке, 
обслуживающим принятые сигналы от системы управления.
 - локальных методов:
	void showParameters() - выводит в терминал параметры логгера (которые пользователь указывает при запуске приложения).
	void pop_and_parse_signal() - функция, которая берет принятый сигнал из очереди, определяет по имени сигнала его принадлежность и складывает
		в соответсвующий элемент структуры (log_data_t) для последующей записи данных по данной итерации.
	void waiting_newsignal() - блокирует поток, пока не будут получены сигналы, доступные для обработки (пока число элементов очереди не станет больше 0).
	void stop_waiting_newsignal() - уничтожает семафор, блокирующий поток.
	-используемые структуры:
	log_data_t - перечень данных, записываемых в лог-файл.
	data_t - данные логгера (входной порт, путь к лог-файлу).
	recvsignal_data_t - структура для передачи аргументов в поток, принимающий сигналы от клиента.
"queue.cpp" - файл, который включает в себя реализацию потокобезопасной очереди, которая может хранить в себе указатели 
	на различный тип данных (любую структуру, представленную как void*).
"tcplib.cpp" - файл, включающий в себя реализацию классов "TCP_client" и "TCP_server", набор соответствующих методов для инициализации
	TCP-соединения, передачи и приема данных.
"signal.cpp" - файл, в котором находится описание структуры сигнала, содержащего имя сигнала, id и значения (value). 
	Также, в этом файле расположены все функции для работы с сигналами: создание сигнала, создание символьного сообщения из структуры,
	получение символьного сообщения из готовой структуры, а также парсинг имени сигнала, парсинг id сигнала, парсинг значения сигнала.
Описание работы:
	Производится инициализация объекта класса Logger (которая включает в себя настройку всех необходимых подключений).
	Создаются два потока, один принимает сигналы и складывает в потокобезопасную очередь, после чего разблокирует второй поток
	посредством семафора, второй поток находится в ожидании сигнала от семафора, как только сигнал приходит, производится получение и
	обработка сигнала из очереди. Как только будут приняты все необходимые сигналы по данной итерации, второй поток вызывает метод  update() для объекта класса Logger. 
	После принятия каждого сигнала логгер отвечает эхом как сигнал подтверждения приема (для исключения записи в лог недостоверных данных). 
	И так, по циклу, пока приходят сигналы по каждой итерации от системы управления.